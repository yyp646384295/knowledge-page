import{_ as n,T as e,C as t,B as o}from"./index-DYEX4BEe1751372422984.js";import{bF as a,bT as l,c7 as r,c5 as i,c2 as s,bU as u,bX as c}from"./chunk-vendor-ROZ06YTY1751372422984.js";import"./chunk-element-plus-BlwndwKp1751372422984.js";import"./chunk-vue-router-DBtsglj51751372422984.js";import"./chunk-pinia-C7gn7-1H1751372422984.js";import"./chunk-nprogress-DVqohuhc1751372422984.js";import"./chunk-axios-rSMZb3Ae1751372422984.js";const p=n(Object.assign({name:"Vue3Base"},{__name:"baseApi",setup:n=>(a((()=>{})),(n,a)=>(u(),l(s,null,[r(e,{title:"router"},{default:i((()=>[r(t,{code:"\n  import {useRouter} from 'vue'\n  const router = useRouter();\n  const test = () => {\n    router.push('/');\n  }\n",lazyLoad:""})])),_:1}),r(e,{title:"route"},{default:i((()=>[r(t,{code:"\nimport {useRoute} from 'vue'\nconst route = useRoute();\n// 当前路由的地址，不包含参数、hash\nconst path = route.path;\n// 包含参数、hash\nconst fullPath = route.fullPath;\n",lazyLoad:""})])),_:1}),r(e,{title:"watchEffect"},{default:i((()=>[r(o,null,{default:i((()=>a[0]||(a[0]=[c("p",null,"立即运行一个函数，同时响应式地追踪其依赖，并在依赖更改时重新执行",-1),c("p",null,"好处：监听多个依赖项，不需要指定监听源，可以消除手动维护依赖列表的负担",-1),c("p",null,"注意：如果异步创建了监听器，则不会自动关闭，需要手动销毁否则造成内存泄露",-1)]))),_:1,__:[0]}),r(t,{code:'\n  import { watchEffect, watchPostEffect, onUnmounted } from "vue";\n\n  const unWatchEffect =  watchEffect(async () => {}, {\n    flush: "post" // 如何想在回调中访问被Vue更新之后的Dom\n  });\n\n  watchPostEffect(() => {\n    /* 在 Vue 更新后执行 */\n  });\n\n  // 手动销毁\n  onUnmounted(() => {\n    unWatchEffect();\n  })\n',lazyLoad:""})])),_:1}),r(e,{title:"watch"},{default:i((()=>[r(o,null,{default:i((()=>a[1]||(a[1]=[c("p",null,"对单一依赖进行监听",-1)]))),_:1,__:[1]}),r(t,{code:'\n  import { watch,useRoute } from "vue";\n  const route = useRoute();\n  watch(\n    () => route,\n    newRoute => {\n      // ...\n    },\n    { deep: true, immediate: true }\n  );\n  // 监听一个ref\n  const visible = ref(false);\n  watch(visible, (newValue) => {\n\n  })\n',lazyLoad:""})])),_:1}),r(e,{title:"customRef"},{default:i((()=>[r(o,null,{default:i((()=>a[2]||(a[2]=[c("p",null,"自定义ref增强",-1)]))),_:1,__:[2]}),r(t,{code:'\n  import { customRef } from "vue";\n\n  /**\n  * 全局loading变量，多个请求保持loading状态，而不会在1个请求结束后关闭loading\n  */\n  export const loading = customRef((track, trigger) => {\n    let loadingCount = 0;\n    return {\n      // loading.value会触发get\n      get() {\n        track(); // 收集哪些地方调用了这个依赖，后续通知更新\n        // loadingCount为0自动关闭loading状态\n        return loadingCount > 0;\n      },\n      set(value) {\n        // 如果loading设置为true就+1否则-1\n        loadingCount += value ? 1 : -1;\n        loadingCount = Math.max(0, loadingCount); // 处理边界，如果小于0就赋值为0\n        console.log(loadingCount);\n        trigger(); // 通知更新\n      }\n    };\n  });\n',lazyLoad:""})])),_:1}),r(e,{title:"Teleport"},{default:i((()=>[r(o,null,{default:i((()=>a[3]||(a[3]=[c("p",null,"专门用于将模板中的某部分 DOM 移动到其他容器",-1)]))),_:1,__:[3]}),r(t,{code:'\n  <template>\n    <teleport to="body">\n      <div class="modal-backdrop" v-if="visible">\n        <div class="modal">\n          <slot />\n        </div>\n      </div>\n    </teleport>\n  </template>\n  \x3c!-- 或者 --\x3e\n  <template>\n    <teleport to="#id">\n      <div class="modal-backdrop" v-if="visible">\n        <div class="modal">\n          <slot />\n        </div>\n      </div>\n    </teleport>\n  </template>\n',language:"html",lazyLoad:""})])),_:1}),r(e,{title:"provide/inject"},{default:i((()=>[r(o,null,{default:i((()=>a[4]||(a[4]=[c("p",null,"用于跨组件层级传递数据，避免props逐级传递（prop drilling）",-1),c("p",null,"provide提供数据，inject注入数据，适用于组件树中深层次组件通信",-1),c("p",null,"注意：默认非响应式，需要使用ref或reactive包装以保持响应性",-1)]))),_:1,__:[4]}),r(t,{code:'\n  // 父组件 (提供数据)\n  import { provide, ref, reactive, readonly } from "vue";\n  \n  // 非响应式值\n  provide("staticMessage", "这是一个静态消息");\n  \n  // 响应式值\n  const count = ref(0);\n  provide("counter", count); // 直接提供ref，保持响应性\n  \n  // 提供修改方法，避免子组件直接修改状态\n  provide("incrementCount", () => {\n    count.value++;\n  });\n  \n  // 对象写法：使用Symbol作为注入键，避免命名冲突\n  const userSymbol = Symbol(\'user\');\n  const userState = reactive({\n    name: \'张三\',\n    age: 25,\n    role: \'admin\'\n  });\n  \n  // 使用readonly包装，防止子组件修改状态\n  provide(userSymbol, readonly(userState));\n  \n  // 提供修改方法\n  provide(\'updateUser\', (newName) => {\n    userState.name = newName; // 只在提供方修改状态\n  });\n',lazyLoad:""}),a[5]||(a[5]=c("hr",null,null,-1)),r(t,{code:"\n  // 子/孙组件 (注入数据)\n  import { inject } from \"vue\";\n  \n  // 注入值，可以设置默认值\n  const message = inject(\"staticMessage\", \"默认消息\");\n  \n  // 注入响应式数据\n  const counter = inject(\"counter\");\n  \n  // 注入方法\n  const increment = inject(\"incrementCount\");\n  \n  // 使用Symbol注入键获取数据\n  const userSymbol = Symbol('user');\n  const user = inject(userSymbol);\n  const updateUser = inject('updateUser');\n  \n  // 使用\n  const handleClick = () => {\n    increment(); // 调用注入的方法修改数据\n    console.log(counter.value); // 访问响应式数据\n    \n    // 尝试修改user对象（会失败，因为是只读的）\n    // user.name = '李四'; // 这会产生警告，因为user是只读的\n    \n    // 正确的修改方式是调用提供的方法\n    updateUser('李四');\n    console.log(user.name); // 输出: 李四\n  };\n  \n  // 使用对象形式的inject，可以设置默认值和是否必须\n  const userConfig = inject('config', { theme: 'light' }, true); // 第三个参数true表示这是必须的\n",lazyLoad:""}),a[6]||(a[6]=c("hr",null,null,-1)),r(t,{code:"\n  // App级别提供全局配置 (app.vue或main.js)\n  import { provide, reactive } from \"vue\";\n  \n  // 应用级别的provide\n  const app = createApp(App);\n  \n  // 全局配置对象\n  const globalConfig = reactive({\n    apiBaseUrl: 'https://api.example.com',\n    theme: 'light',\n    features: {\n      darkMode: true,\n      notifications: true\n    }\n  });\n  \n  // 在应用级别提供，所有组件都可以注入\n  app.provide('globalConfig', globalConfig);\n  \n  // 也可以使用对象形式一次提供多个值\n  app.provide('appContext', {\n    version: '1.0.0',\n    env: 'production',\n    updateConfig(key, value) {\n      if (key in globalConfig) {\n        globalConfig[key] = value;\n      }\n    }\n  });\n",lazyLoad:""}),a[7]||(a[7]=c("hr",null,null,-1)),r(t,{code:"\n  // 在任意组件中使用全局提供的值\n  \n  // 方式1: 直接在组件中使用inject\n  <script setup>\n  import { inject, computed } from 'vue';\n  \n  // 注入全局配置\n  const globalConfig = inject('globalConfig');\n  const appContext = inject('appContext');\n  \n  // 使用配置创建计算属性\n  const apiUrl = computed(() => `${globalConfig.apiBaseUrl}/users`);\n  const isDarkMode = computed(() => globalConfig.features.darkMode);\n  \n  // 切换主题\n  function toggleTheme() {\n    globalConfig.theme = globalConfig.theme === 'light' ? 'dark' : 'light';\n    // 或者使用提供的方法\n    appContext.updateConfig('theme', globalConfig.theme === 'light' ? 'dark' : 'light');\n  }\n  <\/script>\n  \n  // 方式2: 创建可复用的组合式函数 (composable)\n  // useAppConfig.js\n  import { inject } from 'vue';\n  \n  export function useAppConfig() {\n    const globalConfig = inject('globalConfig', {}, true); // 设置为必须\n    const appContext = inject('appContext', {}, true);\n    \n    // 返回需要的数据和方法\n    return {\n      config: globalConfig,\n      version: appContext.version,\n      env: appContext.env,\n      updateConfig: appContext.updateConfig,\n      \n      // 添加便捷方法\n      toggleDarkMode() {\n        const current = globalConfig.features.darkMode;\n        appContext.updateConfig('features', {\n          ...globalConfig.features,\n          darkMode: !current\n        });\n      }\n    };\n  }\n  \n  // 在组件中使用\n  <script setup>\n  import { useAppConfig } from './composables/useAppConfig';\n  \n  // 获取应用配置\n  const { config, toggleDarkMode, version } = useAppConfig();\n  \n  console.log('App version:', version);\n  console.log('Current theme:', config.theme);\n  <\/script>\n",lazyLoad:""})])),_:1,__:[5,6,7]}),r(e,{title:"defineExpose"},{default:i((()=>[r(o,null,{default:i((()=>a[8]||(a[8]=[c("p",null,"用于子组件向外暴露自身变量、方法提供外部使用",-1)]))),_:1,__:[8]}),r(t,{code:"\n// a.vue 子组件\n  import {ref} from \"vue\";\n  const a = ref('');\n  const test = () => {\n    console.log(\"test\");\n  }\n\n  defineExpose(({\n    a,\n    test,\n    set: ()=>{\n      a.value = 'bab'\n    }\n  }))\n",lazyLoad:""}),a[9]||(a[9]=c("hr",null,null,-1)),r(t,{code:'\n  \x3c!-- b.vue 父组件 --\x3e\n  <template>\n      <A ref="aRef"/>\n  </template>\n  <script setup>\n    import {ref,nextTick} from "vue";\n    const aRef = ref(\'\'); // 获取dom\n    nextTick(() => {\n      aRef.value.a = "from-b"\n      aRef.value.set();\n    })\n  <\/script>\n',language:"html",lazyLoad:""})])),_:1,__:[9]}),r(e,{title:"defineEmits"},{default:i((()=>[r(o,null,{default:i((()=>a[10]||(a[10]=[c("p",null,"在父组件中，可以通过监听子组件的 handle-click 事件来获取点击动作",-1)]))),_:1,__:[10]}),r(t,{code:'\n  // 子组件传递\n  const emit = defineEmits(["handle-click"]);\n  const handleClick = () => {\n    emit("handle-click"); // 触发事件\n  };\n  // 父组件接收\n  <A @handleClick="onSubmit" />\n',lazyLoad:""})])),_:1}),r(e,{title:"defineOptions"},{default:i((()=>[r(o,null,{default:i((()=>a[11]||(a[11]=[c("p",null,"1. 组件设置组件选项",-1),c("p",null,"2. 相当于以前 export default 中的选项",-1),c("p",null,"注意: Vue 3.3+新增语法糖",-1)]))),_:1,__:[11]}),r(t,{code:'\n  /**\n    inheritAttrs: 告诉 Vue 不要将未被组件显式接收（props）的属性，自动添加到组件的根元素上.可以自动选择在哪个标签上接收组件传递过来的prop\n    比如:\n    \x3c!-- 未设置时 --\x3e\n    \x3c!-- 使用组件时 --\x3e\n    <CommonDrawer class="custom-class" data-test="123" />\n    \x3c!-- 组件CommonDrawer内部接收 --\x3e\n    <template>\n      <div class="drawer-wrapper custom-class" data-test="123">\n          \x3c!-- 打算将外部组件的props直接v-bind绑定到这个组件的，但是未设置inheritAttrs：false就会被添加到根标签上 --\x3e\n         <el-drawer></el-drawer>\n      </div>\n    </template>\n\n    \x3c!-- 设置时 --\x3e\n    \x3c!-- 使用组件时 --\x3e\n    <CommonDrawer class="custom-class" data-test="123" />\n    \x3c!-- 组件CommonDrawer内部接收 --\x3e\n    <template>\n      <div class="drawer-wrapper">\n          \x3c!-- 直接将组件的props绑定到所需要的元素上，并且不会自动加到根元素 --\x3e\n         <el-drawer v-bind="$attrs"></el-drawer>\n      </div>\n    </template>\n  */\n  defineOptions({\n    inheritAttrs: false,\n    name: "ErMessage"\n  });\n  // 等价于\n  export default {\n    name: "ErMessage"\n  }\n',lazyLoad:""})])),_:1}),r(e,{title:"defineProps"},{default:i((()=>[r(t,{code:"\n    const props = defineProps({\n      code: { type: String, required: true },\n      language: { type: String, default: 'javascript' },\n    })\n",lazyLoad:""})])),_:1})],64)))}),[["__scopeId","data-v-781a9199"]]);export{p as default};
