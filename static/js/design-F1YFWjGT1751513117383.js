import{T as n,B as e,C as t}from"./index-BOG8cv9l1751513117383.js";import{bT as o,c7 as s,c5 as a,bU as r,bX as l}from"./chunk-vendor-CULMtnLz1751513117383.js";import"./chunk-element-plus-CSn1MVR81751513117383.js";import"./chunk-vue-router-F28Wd3tB1751513117383.js";import"./chunk-pinia-u8SFST0Z1751513117383.js";import"./chunk-nprogress-DVqohuhc1751513117383.js";import"./chunk-axios-rSMZb3Ae1751513117383.js";const c={__name:"design",setup:c=>(c,u)=>(r(),o("div",null,[s(n,{title:"原型模式"},{default:a((()=>[s(e,null,{default:a((()=>u[0]||(u[0]=[l("p",null,"作用: 公共方法存放在原型",-1),l("p",null,"好处: 在原型添加新方法，现有实例即时生效; 内存节省",-1)]))),_:1,__:[0]}),s(t,{code:"\n  // 定义敌人原型\n  function Enemy(type) {\n    this.type = type;\n  }\n\n  // 共享攻击方法（所有敌人都会）\n  Enemy.prototype.attack = function() {\n    console.log(`${this.type}发起攻击！`);\n  };\n\n  // 创建实例\n  const dragon = new Enemy('火龙');\n  const goblin = new Enemy('哥布林');\n\n  dragon.attack();  // 火龙发起攻击！\n  goblin.attack();  // 哥布林发起攻击！\n\n  // 验证方法共享\n  console.log(dragon.attack === goblin.attack); // true ✅\n"})])),_:1}),s(n,{title:"工厂模式"},{default:a((()=>[s(e,null,{default:a((()=>u[1]||(u[1]=[l("p",null,"作用: 根据不同的需求创建不同类型的对象,不需要去new直接获取实例",-1)]))),_:1,__:[1]}),s(t,{code:'\n  // 定义一个基类 Animal\n  class Animal {\n    speak() {\n      return this.makeSound();\n    }\n  }\n\n  // 定义具体的 Dog 类\n  class Dog extends Animal {\n    makeSound() {\n      return "Woof"; // 狗的叫声\n    }\n  }\n\n  // 定义具体的 Cat 类\n  class Cat extends Animal {\n    makeSound() {\n      return "Meow"; // 猫的叫声\n    }\n  }\n\n  // 工厂类，负责创建不同类型的动物对象\n  class AnimalFactory {\n    createAnimal(type) {\n      switch (type) {\n        case "dog":\n          return new Dog(); // 创建 Dog 实例\n        case "cat":\n          return new Cat(); // 创建 Cat 实例\n        default:\n          throw new Error("Unknown animal type"); // 如果类型未知，抛出错误\n      }\n    }\n  }\n\n  // 使用工厂模式创建对象\n  const factory = new AnimalFactory();\n  const dog = factory.createAnimal("dog"); // 创建 Dog 实例\n  console.log(dog.speak()); // 输出：Woof\n  const cat = factory.createAnimal("cat"); // 创建 Cat 实例\n  console.log(cat.speak()); // 输出：Meow\n'})])),_:1}),s(n,{title:"单例模式"},{default:a((()=>[s(e,null,{default:a((()=>u[2]||(u[2]=[l("p",null,"作用: 确保一个类只有一个实例，并提供一个全局访问点",-1),l("p",null,"实现: 如果存在实例则返回当前实例",-1)]))),_:1,__:[2]}),s(t,{code:'\n  // 定义一个 Logger 类\n  class Logger {\n    constructor() {\n      if (Logger.instance) {\n        return Logger.instance; // 如果已经存在实例，直接返回\n      }\n      this.messages = []; // 用于存储日志消息\n      Logger.instance = this; // 保存当前实例\n    }\n\n    log(message) {\n      this.messages.push(message); // 添加日志消息\n    }\n\n    getLogs() {\n      return this.messages; // 获取所有日志消息\n    }\n  }\n\n  // 使用单例模式\n  const logger1 = new Logger();\n  logger1.log("Hello"); // 添加日志\n\n  const logger2 = new Logger();\n  logger2.log("World"); // 添加日志\n\n  console.log(logger1.getLogs()); // 输出：["Hello", "World"]\n  console.log(logger1 === logger2); // 输出：true（logger1 和 logger2 是同一个实例）\n'})])),_:1}),s(n,{title:"代理模式"},{default:a((()=>[s(e,null,{default:a((()=>u[3]||(u[3]=[l("p",null,"作用: 通过创建一个代理对象来控制对实际对象的访问，代理对象可以添加额外的逻辑，比如权限检查、缓存、远程调用等",-1)]))),_:1,__:[3]}),s(t,{code:'\n  // 定义一个真实对象\n  class RealSubject {\n    request() {\n      return "RealSubject: Handling request."; // 真实对象的请求方法\n    }\n  }\n\n  // 定义一个代理对象\n  class Proxy {\n    constructor(realSubject) {\n      this.realSubject = realSubject; // 保存真实对象的引用\n    }\n\n    request() {\n      if (this.checkAccess()) { // 检查权限\n        this.realSubject.request(); // 调用真实对象的请求方法\n        this.logAccess(); // 记录日志\n      }\n    }\n\n    checkAccess() {\n      console.log("Proxy: Logging the time of request."); // 记录请求时间\n      return true; // 假设权限检查通过\n    }\n\n    logAccess() {\n      console.log("Proxy: Logging the request."); // 记录请求\n    }\n  }\n\n  // 使用代理模式\n  const realSubject = new RealSubject(); // 创建真实对象\n  const proxy = new Proxy(realSubject); // 创建代理对象\n  proxy.request(); // 调用代理的请求方法\n'})])),_:1}),s(n,{title:"观察者模式"},{default:a((()=>[s(e,null,{default:a((()=>u[4]||(u[4]=[l("p",null,"作用: 一对多的依赖关系，让多个观察者对象同时监听某一个主题对象;当主题对象发生变化时，所有依赖它的观察者都会自动收到通知并进行更新",-1)]))),_:1,__:[4]}),s(t,{code:'\n  class Subject {\n    constructor(age) {\n      this.observers = [];\n      this._data = { name: "张三" }; \n      this._data.age = age; // 假设这是他们要订阅的数据\n      console.log(this._data);\n    }\n\n    addObserver(observer) {\n      this.observers.push(observer);\n    }\n\n    removeObserver(observer) {\n      this.observers = this.observers.filter(item => item !== observer);\n    }\n\n    notify() {\n      this.observers.forEach(observer => observer.update(this._data));\n    }\n\n    // 修改数据的方法\n    setData(age) {\n      this._data.age = age;\n      this.notify(); // 数据变化后通知所有观察者\n    }\n  }\n\n  // 观察者1\n  class ObserverA {\n    update(data) {\n      console.log("观察者A收到更新:", data.age);\n    }\n  }\n\n  // 观察者2\n  class ObserverB {\n    update(data) {\n      console.log("观察者B收到更新:", `Hello, ${data.age}`);\n    }\n  }\n\n  // 使用示例\n  const subject = new Subject(23);\n\n  const a = new ObserverA();\n  const b = new ObserverB();\n\n  subject.addObserver(a);\n  subject.addObserver(b);\n\n  // 更新数据\n  subject.setData(25);\n'})])),_:1}),s(n,{title:"策略模式"},{default:a((()=>[s(e,null,{default:a((()=>u[5]||(u[5]=[l("p",null,"作用: 定义一系列算法,封装起来提供选择",-1)]))),_:1,__:[5]}),s(t,{code:"\n  // 定义一个上下文对象\n  class Context {\n    constructor(strategy) {\n      this.strategy = strategy; // 保存策略对象\n    }\n\n    executeStrategy(a, b) {\n      return this.strategy(a, b); // 执行策略\n    }\n  }\n\n  // 定义加法策略\n  function addStrategy(a, b) {\n    return a + b; // 加法运算\n  }\n\n  // 定义减法策略\n  function subtractStrategy(a, b) {\n    return a - b; // 减法运算\n  }\n\n  // 使用策略模式\n  const context = new Context(addStrategy); // 使用加法策略\n  console.log(context.executeStrategy(10, 5)); // 输出：15\n\n  context.strategy = subtractStrategy; // 切换到减法策略\n  console.log(context.executeStrategy(10, 5)); // 输出：5\n\n"})])),_:1}),s(n,{title:"装饰器模式"},{default:a((()=>[s(e,null,{default:a((()=>u[6]||(u[6]=[l("p",null,"作用: 通过组合的方式，动态地扩展对象的功能",-1)]))),_:1,__:[6]}),s(t,{code:"\n  class Components {\n    opertion() {\n      return '这是组件基类'\n    }\n  }\n\n  class CustomComponent extends Components {\n    opertion() {\n      return '这是自定义组件'\n    }\n  }\n\n  // 在不修改自定义组件方法的前提下新增新功能\n  class Decorator extends Components {\n    constructor(component) {\n      super()\n      this.component = component\n    }\n    opertion() {\n      // ...添加新功能\n      console.log('装饰器添加的新功能...');\n      return '这是装饰器' + this.component.opertion()\n    }\n  }\n\n  const custom = new CustomComponent();\n  console.log(custom.opertion());\n\n  const decorator = new Decorator(custom);\n  console.log(decorator.opertion());\n"})])),_:1}),s(n,{title:"适配器模式"},{default:a((()=>[s(e,null,{default:a((()=>u[7]||(u[7]=[l("p",null,"作用: 将一个类的接口转换成客户希望的另一个接口，使原本不兼容的接口能够兼容",-1)]))),_:1,__:[7]}),s(t,{code:'\n  // 具体播放器 - MP3（原生支持）\n  class Mp3Player {\n    play(fileName) {\n      console.log(`MP3 Player: 正在播放文件 - ${fileName}`);\n    }\n  }\n\n  // 高级播放器 - VLC\n  class VlcPlayer {\n    play(fileName) {\n      console.log(`VLC Player: 正在播放 VLC 文件 - ${fileName}`);\n    }\n  }\n\n\n  // 高级播放器 - MP4\n  class Mp4Player {\n    play(fileName) {\n      console.log(`MP4 Player: 正在播放 MP4 文件 - ${fileName}`);\n    }\n  }\n\n  // 适配器统一接口\n  class MediaAdapter {\n    // 点击播放,根据不同类型去找到不同的播放器\n    static play(type, fileName) {\n      const player = this._getPlayer(type); // 根据播放类型获取播放器实例\n      if (player) {\n        player.play(fileName)\n      } else {\n        console.log("不支持的音频格式" + type)\n      }\n    }\n\n    // 私有方法：根据类型返回对应的播放器实例\n    static _getPlayer(audioType) {\n      switch (audioType.toLowerCase()) {\n        case \'mp3\':\n          return new Mp3Player();\n        case \'vlc\':\n          return new VlcPlayer();\n        case \'mp4\':\n          return new Mp4Player();\n        default:\n          return null;\n      }\n    }\n  }\n\n  MediaAdapter.play("mp3", "song.mp3");//MP3 Player: 正在播放文件 - song.mp3\n  MediaAdapter.play("vlc", "movie.vlc"); //VLC Player: 正在播放 VLC 文件 - movie.vlc\n  MediaAdapter.play("mp4", "video.mp4");//MP4 Player: 正在播放 MP4 文件 - video.mp4\n  MediaAdapter.play("avi", "test.avi");//不支持的音频格式avi\n'})])),_:1}),s(n,{title:"模板模式"},{default:a((()=>[s(e,null,{default:a((()=>u[8]||(u[8]=[l("p",null,"作用: 它定义了一个算法的骨架，并允许子类在不改变算法结构的前提下重新定义算法中的某些步骤",-1),l("p",null,"固定一个某个行为的流程框架,但是又有一些不同的步骤,把这些步骤抽离出来去分别实现,保证整体流程顺序不变",-1)]))),_:1,__:[8]}),s(t,{code:'\n  class Beverage {\n    // 固定模板方法\n    templateMethod() {\n      this.boilWater();        // 步骤1：烧水\n      this.brew();              // 步骤2：冲泡（每种饮料都是不同的冲泡方式,由子类实现）\n      this.pourInCup();         // 步骤3：倒进杯子里\n      this.addCondiments();    // 步骤4：加调料（每种饮料都是不同的调料,由子类实现）\n    }\n\n    boilWater() {\n      console.log("把水煮沸");\n    }\n\n    brew() {\n      throw new Error("子类必须实现 brew 冲泡方法");\n    }\n\n    pourInCup() {\n      console.log("倒入杯子");\n    }\n\n    addCondiments() {\n      throw new Error("子类必须实现 addCondiments 加调料方法");\n    }\n  }\n\n  class Coffee extends Beverage {\n    brew() {\n      console.log("用热水冲泡咖啡");\n    }\n\n    addCondiments() {\n      console.log("加糖和牛奶");\n    }\n  }\n\n  class Tea extends Beverage {\n    brew() {\n      console.log("用热水冲泡茶叶");\n    }\n\n    addCondiments() {\n      console.log("加柠檬");\n    }\n  }\n\n  // 制作饮料\n  class MakeBeverage {\n    constructor(beverage) {\n      this.beverage = beverage;\n      this.beverage.templateMethod();\n    }\n  }\n\n  console.log(" ********** 制作咖啡 ********** ");\n\n  const coffee = new MakeBeverage(new Coffee());\n  /*\n    把水煮沸\n    用热水冲泡咖啡\n    倒入杯子\n    加糖和牛奶\n  */\n  console.log(" ********** 制作茶 ********** ");\n  const tea = new MakeBeverage(new Tea());\n  /*\n    把水煮沸\n    用热水冲泡茶叶\n    倒入杯子\n    加柠檬\n  */\n'})])),_:1}),s(n,{title:"建造者模式"},{default:a((()=>[s(e,null,{default:a((()=>u[9]||(u[9]=[l("p",null,"作用: 将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示",-1),l("p",null,"把一个复杂的问题简单化分离出来,逐步去构建整体",-1)]))),_:1,__:[9]}),s(t,{code:'\n  // 定义一个复杂对象\n  class Car {\n    constructor() {\n      this.type = null; // 车型\n      this.seats = null; // 座位数\n      this.engine = null; // 发动机类型\n      this.tripComputer = null; // 是否有行程计算机\n      this.gps = null; // 是否有 GPS\n    }\n  }\n\n  // 定义一个建造者类\n  class CarBuilder {\n    constructor() {\n      this.car = new Car(); // 创建一个 Car 实例\n    }\n\n    setType(type) {\n      this.car.type = type; // 设置车型\n      return this; // 返回当前对象，支持链式调用\n    }\n\n    setSeats(seats) {\n      this.car.seats = seats; // 设置座位数\n      return this; // 返回当前对象，支持链式调用\n    }\n\n    setEngine(engine) {\n      this.car.engine = engine; // 设置发动机类型\n      return this; // 返回当前对象，支持链式调用\n    }\n\n    setTripComputer(tripComputer) {\n      this.car.tripComputer = tripComputer; // 设置行程计算机\n      return this; // 返回当前对象，支持链式调用\n    }\n\n    setGPS(gps) {\n      this.car.gps = gps; // 设置 GPS\n      return this; // 返回当前对象，支持链式调用\n    }\n\n    build() {\n      return this.car; // 返回构建好的 Car 实例\n    }\n  }\n\n  // 使用建造者模式\n  const carBuilder = new CarBuilder(); // 创建建造者对象\n  const car = carBuilder\n    .setType("SUV") // 设置车型为 SUV\n    .setSeats(4) // 设置座位数为 4\n    .setEngine("V6") // 设置发动机类型为 V6\n    .setTripComputer(true) // 设置行程计算机为 true\n    .setGPS(true) // 设置 GPS 为 true\n    .build(); // 构建汽车\n\n  console.log(car); // 输出构建好的汽车对象\n'})])),_:1})]))};export{c as default};
